

# 3-2 인덱스의 종류

### 인덱스 종류 및 옵션

1. Single-Key / Compound Key
2. Unique / Non-Unique
3. Sparse
4. Partial
5. Background (인덱스 생성 옵션)
6. Covered (검색방식)
7. TTL (인덱스 관리 옵션)
8. GeoSpartial
9. GeoMetry



## 1. Single-Key / Compound Key

말 그대로 인덱스의 키가 1개 or 여러개 의 차이



#### 싱글 키 인덱스

````javascript
db.employees.createIndex({empno: 1}) // 1: Asc, -1: Desc
````



#### 복합 키 인덱스

````javascript
db.employees.createIndex({empno: 1, deptno: -1})
````





## 2. Unique / Non-Unique

인덱스의 값들이 유일값(Unique) 인지 중복값이 있는지(Non-Unique)의 차이

기본값: false (Non-Unique)



#### Unique Index

````javascript
db.employees.createIndex({empno: 1}, {unique: true})
````

* 인덱스 생성 전 이미 대상에 중복값이 있었다면 에러 발생



#### Non-Unique Index

````javascript
db.employees.createIndex({empno: 1}) // 기본값: {unique: false}
````





## 3. Sparse

**검색 대상 필드가 전체에서 차지하는 비중이 낮은 경우**에 유리

(전체 대상 Full Collection 검색보다 해당 조건을 만족하는 Document 로 만 Sparse 인덱스 생성 & 검색하기 때문에 더 빠름)



아래와 같은 경우 prize 필드는 일부의 소수에게만 있으므로 sparse 인덱스로 구성하기 좋음



#### Example

* 90%의 일반적인 employees 필드: empno, ename, deptno
* 10%의 소수의 수상내역 있는 employess 필드: empno, ename, deptno, <font color="red">**prize**</font>

````javascript
db.employees.createIndex({prize: 1}, {sparse: true}) // prize 필드가 있는 doc만 인덱스 생성
````





## 4. Partial

특정 컬럼에서 **조건을 만족하는 데이터에서 추가로 조건을 또 만족하는 값을 검색**할 때 유리

즉, **조건을 만족하는 일부 doc 에만 인덱스 적용**



#### Example

* 1번 부서에서 연봉(salary)이 1억 넘는 사원들만 인덱스 적용

````javascript
db.employees.createIndex(
	{deptno: 1},
    {
        partialFilterExpression: {
        	sal: {$gt: 10000000}	// 1번 부서에서 연봉이 1억 넘는 사원들만 인덱스 생성
    	}
    }
)
````

<img src="https://user-images.githubusercontent.com/20942871/46904667-f3beb700-cf22-11e8-8bc5-4a1e9d446a2f.png" />





## 5. Background

인덱스 생성을 백그라운드에서 진행함

시스템 자원 부족한 환경 또는 빅 데이터 인덱싱의 상황에서 유용함



#### Example

````javascript
db.employees.createIndex({eno: 1}, {background: true})
````





## 6. Covered

여러 필드로 생성된 인덱스 검색 시 Index 만의 검색 만으로도 조건을 만족하는 doc을 추출하는 경우

인덱스 스캔의 경우 **인덱스를 통해 조건 만족하는 데이터 검색** 후, **컬렉션에 대한 추가 검색**을 통해 데이터 추출하는데, **인덱스 검색만으로 해결할 수 있는 경우** Covered 인덱스 생성하여 해당 인덱스 검색만으로 빠르게 처리 가능



#### Example

* employees 에서 _id는 제외하고 **부서번호와 이름만** 검색할 때

````javascript
db.employees.createIndex({deptno: 1, ename: 1}); // deptno와 ename에 인덱스
db.employees.find(
    {deptno: 3, ename: "Kim"}, // 검색 조건 = 3번 부서의 Kim 씨
    {_id: 0, ename: 1} // 노출 대상(실제 검색 대상)에서 _id 를 제외(값이 0)
);
````

* 실행계획 확인

  * Covered 인 경우

    ````javas
    db.employees.find({deptno: 3, ename: "Kim"}, {_id: 0, ename: 1}).explain() // Covered
    ````

    <img src="https://user-images.githubusercontent.com/20942871/46904952-7ba6c000-cf27-11e8-911d-ca4aaab645b0.png" width="50%"/>

  * Covered 가 아닌 경우

    ````javascript
    db.employees.find({deptno: 3, ename: "Kim"}).explain() // Not Covered
    ````

    <img src="https://user-images.githubusercontent.com/20942871/46904969-caecf080-cf27-11e8-9d42-8c2863e4caa9.png" width="50%"/>





